{"version":3,"file":"event-dispatcher.js","sourceRoot":"","sources":["event-dispatcher.ts"],"names":[],"mappings":";;;AAQA;;;;GAIG;AACH,MAAa,eAAe;IAA5B;QAEE;;WAEG;QACH,iBAAY,GAAuC,EAAwC,CAAC;QAE5F;;WAEG;QACH,YAAO,GAAoC,EAAqC,CAAC;IA0DnF,CAAC;IAxDC;;;;;;OAMG;IACH,MAAM,CAEJ,IAAQ,EAER,QAA8C,EAAE,KAA4B;QAI5E,IAAI,CAAC,OAAO,CAAE,IAAI,CAAE,GAAG,IAAI,CAAC,OAAO,CAAE,IAAI,CAAE,IAAI,EAAE,CAAA;QAEjD,IAAI,CAAC,OAAO,CAAE,IAAI,CAAE,CAAC,IAAI,CAAE,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC,CAAA;QAE/C,IAAI,CAAC,YAAY,CAAE,IAAI,CAAE,GAAG,KAAK,CAAC;QAElC,OAAO,IAAI,CAAC;IAEd,CAAC;IAED;;;;;;;OAOG;IACH,QAAQ,CAAE,IAAmB,EAAE,IAAS;QAEtC,IAAI,IAAI,CAAC,OAAO,CAAE,IAAI,CAAE,EAAE,CAAC;YAEzB,IAAI,CAAC,OAAO,CAAE,IAAI,CAAE,CAAC,GAAG,CAAE,CAAC,KAAK,EAAE,EAAE;gBAElC,IAAI,IAAI,CAAC,YAAY,CAAE,IAAI,CAAE,KAAK,IAAI,EAAE,CAAC;oBAAC,OAAO;gBAAC,CAAC;gBAEnD,MAAM,IAAI,GAAG,KAAK,CAAC,QAAQ,CAAE,IAAI,CAAE,CAAA;gBAEnC,IAAI,IAAI,KAAK,IAAI,EAAE,CAAC;oBAAC,IAAI,CAAC,YAAY,CAAE,IAAI,CAAE,GAAG,IAAI,CAAC;gBAAC,CAAC;YAE1D,CAAC,CAAC,CAAA;YAEF,IAAI,CAAC,YAAY,CAAE,IAAI,CAAE,GAAG,KAAK,CAAC;QAEpC,CAAC;QAED,OAAO,IAAI,CAAC;IAEd,CAAC;CAGF;AApED,0CAoEC","sourcesContent":["import type { \n  IEventDispatcher, \n  IEventDispatcherCallback, \n  IEventDispatcherEntries, \n  IEventDispatcherProgations, \n  IEventDispatcherScheme \n} from \"../types\";\n\n/**\n * Protorian EventDispatcher — Emetteur d'émission\n * @description Gestionnaire d'évènements\n * @example new EventDispatcher<EmitScheme>()\n */\nexport class EventDispatcher<Scheme extends IEventDispatcherScheme> implements IEventDispatcher<Scheme> {\n\n  /**\n   * Gestion de la propagation\n   */\n  propagations: IEventDispatcherProgations<Scheme> = {} as IEventDispatcherProgations<Scheme>;\n\n  /**\n   * Stockage des émissions\n   */\n  entries: IEventDispatcherEntries<Scheme> = {} as IEventDispatcherEntries<Scheme>;\n\n  /**\n   * Ecouter une émission de l'émetteur\n   * @description Ecouteur d'évèvements par rapport à un \"SLUG\". Utiliser un retour \"TRUE\" pour stopper la propagation de l'instance déclenchée\n   * @param type Type d'émission déclaré dans le `Scheme` de l'instanciation\n   * @param callback Fonction de rappel content en `argument[0]` les données définit par le dispatcher\n   * @example emitter.listen<ReturnType>( 'emitterNameInKeyOfScheme', ( data : ReturnType ) => ... )\n   */\n  listen<I extends keyof Scheme>( \n    \n    type : I, \n    \n    callback : IEventDispatcherCallback<Scheme[I]>, force ?: boolean | undefined \n    \n  ) : this{\n\n    this.entries[ type ] = this.entries[ type ] || []\n\n    this.entries[ type ].push( { callback, force })\n\n    this.propagations[ type ] = false;\n\n    return this;\n    \n  }\n\n  /**\n   * Déclencheur un type d'émission de l'émetteur\n   * @description Déclencheur les écouteurs par rapport au `type`\n   * @param type Type d'émission déclaré dans le `Scheme` de l'instanciation\n   * @param data Donnée à renvoyer aux écouteurs d'émission de l'émeteur\n   * @example emitter.dispatch( 'emitterNameInKeyOfScheme', ... )\n   * \n   */\n  dispatch( type : keyof Scheme, data: any ) : this{\n\n    if( this.entries[ type ] ){\n\n      this.entries[ type ].map( (entry) => {\n\n        if( this.propagations[ type ] === true ){ return; }\n\n        const stop = entry.callback( data )\n\n        if( stop === true ){ this.propagations[ type ] = true; }\n        \n      })\n      \n      this.propagations[ type ] = false;\n      \n    }\n\n    return this;\n    \n  }\n  \n\n}\n"]}